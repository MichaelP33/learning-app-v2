{
  "title": "Relational Databases Quiz",
  "totalQuestions": 10,
  "totalPoints": 25,
  "questions": [
    {
      "id": "1",
      "type": "multiple-choice",
      "points": 2,
      "question": "PR writes touch orders, payments, and inventory together. Which review ask best validates all-or-nothing behavior?",
      "options": [
        "Show the transaction boundary and failure path; confirm partial writes cannot persist",
        "Increase isolation globally to the strongest level for safety",
        "Add retries so failures eventually succeed without further checks",
        "Move the logic into a stored procedure to make it atomic by default"
      ],
      "correctAnswer": 0,
      "additionalContext": "Headline: confirm atomic all-or-nothing across order, payment, inventory. Why correct: asking to show the transaction boundary and failure path validates atomicity and prevents partial writes that confuse customers and finance. Why others are wrong: raising isolation globally is overreach and may reduce throughput without proving atomicity; retry-only does not stop duplicate effects on failure; a stored procedure is not automatically atomic without an explicit transaction. Cursor leverage: ask Cursor to draft a PR-ready comment that highlights begin and commit points, error handling, and an idempotency guard; have it scan the diff for any write before commit. Acceptance checks: transaction scope documented, negative path tested, idempotency keys in place.",
      "keyConcepts": ["ACID", "Atomicity", "PR review asks"]
    },
    {
      "id": "2",
      "type": "multiple-choice",
      "points": 2,
      "question": "Product wants dashboards to read from replicas. Which expectation should you set up front?",
      "options": [
        "Replicas reflect the primary instantly for all dashboards",
        "Agree on a freshness window and route must-be-fresh reads to the primary",
        "Dashboards should never use replicas to avoid any lag",
        "Dashboards must exactly match the primary at all times"
      ],
      "correctAnswer": 1,
      "additionalContext": "Headline: set a freshness window and route must-be-fresh reads to primary. Why correct: replicas improve read capacity but may lag; users may see old data after save unless paths are routed. Why others are wrong: instant match and exact equality at all times are overpromises; avoiding replicas entirely wastes safe capacity. Cursor leverage: ask Cursor to produce a 2â€“3 sentence PR comment that defines the freshness SLA and identifies which read paths stay on primary; request a small monitoring snippet for replica lag. Acceptance checks: freshness window documented, primary paths identified, lag monitoring defined.",
      "keyConcepts": [
        "Read replicas",
        "Freshness window",
        "Expectation setting"
      ]
    },
    {
      "id": "3",
      "type": "multiple-choice",
      "points": 2,
      "question": "Engineer adds an index on created_at to speed a hot query. What PR comment de-risks this best?",
      "options": [
        "Merge now; indexes are always helpful on hot tables",
        "Also add indexes on every filter column to be safe",
        "Bump the connection pool so the query gets more concurrent slots",
        "Share an EXPLAIN for the hot path and justify a minimal composite index that matches predicates; note write cost"
      ],
      "correctAnswer": 3,
      "additionalContext": "Headline: show plan and choose the smallest index that matches predicates; acknowledge write cost. Why correct: an EXPLAIN confirms plan shape; a minimal composite index that matches equality then range avoids full scans while limiting write amplification. Why others are wrong: merge now or indexing every column is cargo-cult and increases write cost; more pool slots do not fix poor plans. Cursor leverage: ask Cursor to summarize EXPLAIN, propose a minimal composite index DDL, estimate write amplification, and generate a rollback script. Acceptance checks: EXPLAIN attached, slow-query budget stated, index matches predicates, rollback path included.",
      "keyConcepts": ["EXPLAIN", "Indexing trade-offs", "PR review asks"]
    },
    {
      "id": "4",
      "type": "multiple-choice",
      "points": 2,
      "question": "Team proposes raising isolation to Serializable to prevent anomalies. What trade-off must you align on first?",
      "options": [
        "Serializable guarantees infinite throughput at any scale",
        "Higher contention and rollbacks under load; ask for expected concurrency and impact",
        "Read caches will stop working once isolation increases",
        "Storage costs will grow even if workload stays the same"
      ],
      "correctAnswer": 1,
      "additionalContext": "Headline: Serializable reduces anomalies but increases contention and rollbacks. Why correct: you must align on expected concurrency and error budgets before increasing isolation. Why others are wrong: infinite throughput is false; read caches continue to work; storage growth is unrelated. Cursor leverage: ask Cursor to draft questions for expected throughput, conflict rate, and rollback handling; request a short note on fallback isolation per endpoint if regressions appear. Acceptance checks: concurrency profile documented, rollback policy defined, budgeted error rate accepted, fallback path clear.",
      "keyConcepts": ["Isolation", "Throughput trade-offs", "Risk surfacing"]
    },
    {
      "id": "5",
      "type": "multiple-choice",
      "points": 2,
      "question": "Reporting is slow but checkouts are sensitive. What approach keeps product traffic safe while speeding reports?",
      "options": [
        "Move heavy reporting to replicas or materialized views with a freshness SLA",
        "Run reports on the primary and increase CPU until it is fine",
        "Denormalize everything immediately to make all reads fast",
        "Increase isolation so reads are always the latest"
      ],
      "correctAnswer": 0,
      "additionalContext": "Headline: protect product traffic by offloading reporting to replicas or materialized views with a freshness window. Why correct: dashboards can tolerate staleness; OLTP cannot tolerate contention. Why others are wrong: running reports on primary risks slow checkouts; denormalize everything is overreach; raising isolation does not address reporting load. Cursor leverage: ask Cursor to produce an SLA phrasing and a small playbook for routing reads and monitoring lag. Acceptance checks: SLA documented, report paths moved, p95 targets set, alerts created.",
      "keyConcepts": ["Replica routing", "Materialized views", "Freshness SLA"]
    },
    {
      "id": "6",
      "type": "multiple-choice",
      "points": 2,
      "question": "Team wants to denormalize a feed for speed. What must be documented to keep trust?",
      "options": [
        "That the entire app is now eventually consistent everywhere",
        "That no further indexes will ever be needed",
        "That refunds and reversals are no longer supported",
        "Freshness window, source of truth, conflict resolution, and write-amplification budget"
      ],
      "correctAnswer": 3,
      "additionalContext": "Headline: denormalization is safe only with trust guardrails. Why correct: documenting freshness window, source of truth, conflict resolution, and a write-amplification budget prevents confusion and data drift. Why others are wrong: calling the whole app eventually consistent is unnecessary; claiming no future indexes is unrealistic; dropping support for reversals breaks product needs. Cursor leverage: ask Cursor to generate a short design note template that captures these guardrails and a checklist for PR review. Acceptance checks: guardrails filled, reconciliation flow owned, staleness window communicated.",
      "keyConcepts": ["Denormalization", "Trust guardrails", "Documentation"]
    },
    {
      "id": "7",
      "type": "multiple-choice",
      "points": 2,
      "question": "Schema change adds a non-nullable column to a large table. Which plan do you require before approving?",
      "options": [
        "Apply a blocking ALTER during a short maintenance window",
        "Ship the app change first; fix the schema after release",
        "Phase it: add nullable, backfill in batches, flip flag, enforce, then drop old paths",
        "Rename the table to avoid risks and migrate later"
      ],
      "correctAnswer": 2,
      "additionalContext": "Headline: ship schema changes in phases so rush hour never locks the app. Why correct: add then backfill in batches, flip via flag, enforce, and clean up reduces blocking risk and enables rollback. Why others are wrong: blocking ALTER risks downtime; shipping app first can break writes; renaming the table is high-risk and rarely needed. Cursor leverage: ask Cursor to produce a phased plan with batch SQL, metrics to watch, and a rollback toggle. Acceptance checks: batch size and pacing defined, feature flag identified, monitoring and rollback documented.",
      "keyConcepts": ["Phased migrations", "Operational risk", "Rollback plan"]
    },
    {
      "id": "8",
      "type": "multiple-choice",
      "points": 2,
      "question": "Customers report seeing old data right after saving. What is the likely cause and best guidance?",
      "options": [
        "Indexes are corrupt; rebuild all indexes",
        "The database is down; restart the cluster to refresh",
        "Reads hit a replica before catch-up; route freshness-critical reads to the primary and set a freshness window",
        "Disable replicas; transactions are being lost"
      ],
      "correctAnswer": 2,
      "additionalContext": "Headline: this is replica lag; route must-be-fresh paths to primary. Why correct: replicas can serve stale reads immediately after a write; routing and SLA language avoid user confusion. Why others are wrong: index rebuilds or restarts do not address lag; disabling replicas loses safe capacity. Cursor leverage: ask Cursor to draft the PR comment that sets the freshness window and identifies primary-only paths plus a simple lag monitor. Acceptance checks: routes updated, SLA documented, monitoring in place.",
      "keyConcepts": ["Replica lag", "Freshness SLA", "Routing"]
    },
    {
      "id": "9",
      "type": "freeform",
      "points": 4,
      "question": "Draft a PR comment to de-risk a new hot-path query. Include: EXPLAIN plan, slow-query budget target, minimal non-overlapping index rationale, and rollback plan if p95 regresses.",
      "sampleStrongResponse": "Ask for EXPLAIN on the exact WHERE and ORDER BY; confirm the plan avoids full scans and uses a composite index that matches predicates. State the slow-query budget (for example, p95 at or below 120 ms) and propose the smallest non-overlapping index that meets it. Call out write-amplification impact on inserts and updates, and require a rollback toggle or script if p95 regresses after deploy. Use Cursor to summarize EXPLAIN, generate the DDL and rollback, and produce a PR-ready comment."
    },
    {
      "id": "10",
      "type": "freeform",
      "points": 5,
      "question": "Outline a phased migration talk track for a non-nullable column on a large table. Include steps, safety checks, and how you will communicate risk to product and support.",
      "sampleStrongResponse": "Plan: add a nullable column; backfill in batches with monitoring; dual-write and validate; flip a feature flag to switch reads and writes; enforce non-null; remove legacy code. Safety: idempotent writes, timeouts and retry budget, metrics for backfill pace, and a rollback path. Communication: share expected blast radius, any maintenance window, and success metrics such as zero lock timeouts and stable p95. Ask Cursor to draft the step plan, batch SQL, and a stakeholder note for support and product."
    }
  ]
}
